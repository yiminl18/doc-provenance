#!/usr/bin/env python3
"""
PDF Processing Workspace Setup Script
Run this to set up a dedicated Node.js workspace for PDF.js processing
"""

import os
import subprocess
import json
from pathlib import Path

def setup_pdf_workspace(workspace_dir: str = "pdf_stable_workspace", node_path: str = None, npm_path: str = None) -> bool:
    """
    Set up a dedicated workspace for PDF processing with pdfjs-dist
    """
    try:
        workspace_path = Path(os.getcwd()) / workspace_dir
        
        print(f"🔧 Setting up PDF processing workspace at: {workspace_path}")
        
        # Create workspace directory
        workspace_path.mkdir(exist_ok=True)
        
        # Create package.json
        package_json_path = workspace_path / "package.json"
        package_json = {
            "name": "pdf-processing-workspace",
            "version": "1.0.0",
            "description": "Workspace for PDF.js text extraction",
            "main": "extract_pdf.js",
            "dependencies": {
                "pdfjs-dist": "^3.11.174"
            },
            "scripts": {
                "extract": "node extract_pdf.js",
                "test": "node -e \"console.log('pdfjs-dist version:', require('pdfjs-dist/package.json').version)\""
            }
        }
        
        with open(package_json_path, 'w', encoding='utf-8') as f:
            json.dump(package_json, f, indent=2)
        
        print("✅ Created package.json")
        
        # Install dependencies using the found npm path
        npm_cmd = npm_path if npm_path else 'npm'
        print(f"📦 Installing pdfjs-dist using: {npm_cmd}")
        result = subprocess.run([
            npm_cmd, 'install'
        ], cwd=workspace_path, capture_output=True, text=True)
        
        if result.returncode != 0:
            print(f"❌ npm install failed:")
            print(f"Error: {result.stderr}")
            print(f"Output: {result.stdout}")
            return False
        
        print("✅ Dependencies installed successfully")
        
        # Create the extraction script
        extract_script_path = workspace_path / "extract_pdf.js"
        with open(extract_script_path, 'w', encoding='utf-8') as f:
            f.write(create_extraction_script())
        
        print("✅ Created extraction script")
        
        # Create a simple test script
        test_script_path = workspace_path / "test_setup.js"
        with open(test_script_path, 'w', encoding='utf-8') as f:
            f.write('''const pdfjsLib = require('pdfjs-dist/build/pdf');
console.log('✅ pdfjs-dist loaded successfully!');
console.log('Version:', require('pdfjs-dist/package.json').version);
console.log('Worker source:', pdfjsLib.GlobalWorkerOptions.workerSrc || 'null (will use main thread)');
''')
        
        # Test the setup using the found node path
        node_cmd = node_path if node_path else 'node'
        print(f"🧪 Testing workspace setup using: {node_cmd}")
        test_result = subprocess.run([
            node_cmd, 'test_setup.js'
        ], cwd=workspace_path, capture_output=True, text=True)
        
        if test_result.returncode == 0:
            print("✅ Workspace setup successful!")
            print(test_result.stdout)
            
            # Create a README with the correct paths
            readme_path = workspace_path / "README.md"
            with open(readme_path, 'w') as f:
                f.write(f"""# PDF Processing Workspace

This workspace contains the necessary dependencies for PDF.js text extraction.

## Files:
- `package.json` - Node.js dependencies
- `extract_pdf.js` - Main extraction script
- `test_setup.js` - Setup verification script

## Usage:
```bash
cd {workspace_dir}
{node_cmd} extract_pdf.js /path/to/document.pdf
```

## Found Paths:
- Node.js: {node_path or 'system default'}
- npm: {npm_path or 'system default'}

## Dependencies:
- pdfjs-dist: {package_json['dependencies']['pdfjs-dist']}

Generated by setup_workspace.py
""")
            
            print(f"📁 Workspace ready at: {workspace_path}")
            print(f"📖 See {readme_path} for usage instructions")
            return True
        else:
            print(f"❌ Workspace test failed:")
            print(f"Error: {test_result.stderr}")
            print(f"Output: {test_result.stdout}")
            return False
            
    except Exception as e:
        print(f"❌ Error setting up workspace: {e}")
        import traceback
        traceback.print_exc()
        return False

def create_extraction_script() -> str:
    """Create the PDF extraction script for the workspace"""
    return '''const fs = require('fs');
const path = require('path');

// Load pdfjs-dist from workspace
const pdfjsLib = require('pdfjs-dist/build/pdf');

// Set worker source to null to use the main thread
pdfjsLib.GlobalWorkerOptions.workerSrc = null;

async function extractStableTextContent(pdfPath) {
    try {
        if (!fs.existsSync(pdfPath)) {
            throw new Error(`PDF file not found: ${pdfPath}`);
        }
        
        console.error(`📄 Processing PDF: ${pdfPath}`);
        
        const data = new Uint8Array(fs.readFileSync(pdfPath));
        const pdf = await pdfjsLib.getDocument({ 
            data, 
            verbosity: 0,
            standardFontDataUrl: null // Disable font loading to avoid issues
        }).promise;
        
        console.error(`📊 PDF loaded: ${pdf.numPages} pages`);
        
        const pages = [];
        
        for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
            try {
                const page = await pdf.getPage(pageNum);
                const viewport = page.getViewport({ scale: 1.0 });
                const textContent = await page.getTextContent();
                
                console.error(`📄 Processing page ${pageNum}: ${textContent.items.length} text items`);
                
                // Create stable item references with consistent indexing
                const stableItems = textContent.items.map((item, itemIndex) => {
                    const transform = item.transform || [1, 0, 0, 1, 0, 0];
                    
                    // Calculate position consistently
                    const x = transform[4];
                    const y = viewport.height - transform[5]; // Flip Y for top-origin
                    
                    return {
                        // STABLE REFERENCE: Use consistent itemIndex within page
                        stableIndex: itemIndex,
                        pageNumber: pageNum,
                        
                        // Text content
                        str: item.str || '',
                        normalizedText: (item.str || '').toLowerCase().replace(/\\s+/g, ' ').trim(),
                        
                        // Position data
                        x: x,
                        y: y,
                        width: item.width || 0,
                        height: item.height || 0,
                        
                        // Additional metadata for matching
                        dir: item.dir || 'ltr',
                        fontName: item.fontName || 'default',
                        fontSize: item.height || 12,
                        hasEOL: item.hasEOL || false,
                        
                        // Create multiple identification strategies
                        identifiers: {
                            textFingerprint: createTextFingerprint(item.str || '', itemIndex),
                            positionHash: createPositionHash(x, y, item.width || 0, item.height || 0),
                            contextFingerprint: null // Will be filled in context analysis
                        }
                    };
                });
                
                // Add context fingerprints (text before/after for disambiguation)
                stableItems.forEach((item, index) => {
                    const before = index > 0 ? stableItems[index - 1].str : '';
                    const after = index < stableItems.length - 1 ? stableItems[index + 1].str : '';
                    item.identifiers.contextFingerprint = createContextFingerprint(before, item.str, after);
                });
                
                pages.push({
                    pageNumber: pageNum,
                    viewport: {
                        width: viewport.width,
                        height: viewport.height
                    },
                    stableItems: stableItems,
                    itemCount: stableItems.length,
                    textContentHash: createPageTextHash(stableItems)
                });
                
                console.error(`✅ Page ${pageNum} processed: ${stableItems.length} stable items`);
                
            } catch (pageError) {
                console.error(`❌ Error processing page ${pageNum}: ${pageError.message}`);
                pages.push({
                    pageNumber: pageNum,
                    stableItems: [],
                    error: pageError.message
                });
            }
        }
        
        console.error(`🎉 PDF processing complete: ${pages.length} pages processed`);
        
        // Output JSON to stdout
        console.log(JSON.stringify(pages));
        
    } catch (error) {
        console.error(`❌ PDF extraction failed: ${error.message}`);
        process.exit(1);
    }
}

function createTextFingerprint(text, index) {
    // Create a unique fingerprint for text content
    const cleanText = text.toLowerCase().replace(/[^\\w]/g, '');
    return `${cleanText}_${index}_${text.length}`;
}

function createPositionHash(x, y, width, height) {
    // Create position-based hash (rounded to avoid float precision issues)
    return `${Math.round(x)}_${Math.round(y)}_${Math.round(width)}_${Math.round(height)}`;
}

function createContextFingerprint(before, current, after) {
    // Create context-aware fingerprint
    const cleanBefore = (before || '').replace(/[^\\w]/g, '').slice(-10);
    const cleanCurrent = (current || '').replace(/[^\\w]/g, '');
    const cleanAfter = (after || '').replace(/[^\\w]/g, '').slice(0, 10);
    return `${cleanBefore}|${cleanCurrent}|${cleanAfter}`;
}

function createPageTextHash(items) {
    // Create hash of entire page text content for verification
    const allText = items.map(item => item.str).join('');
    return allText.length + '_' + (allText.match(/\\w/g) || []).length;
}

// Main execution
const pdfPath = process.argv[2];
if (!pdfPath) {
    console.error('Usage: node extract_pdf.js <pdf_path>');
    process.exit(1);
}

extractStableTextContent(path.resolve(pdfPath));
'''

def check_node_npm():
    """Check if Node.js and npm are available"""
    import shutil
    
    # First try to find node and npm using shutil.which
    node_path = shutil.which('node')
    npm_path = shutil.which('npm')
    
    print(f"🔍 Looking for Node.js...")
    print(f"   node path: {node_path}")
    print(f"   npm path: {npm_path}")
    
    # Common additional paths where Node.js might be installed
    additional_paths = [
        '/usr/local/bin',
        '/opt/homebrew/bin',  # Apple Silicon Macs
        '/usr/bin',
        os.path.expanduser('~/.nvm/versions/node/*/bin'),
        os.path.expanduser('~/.volta/bin'),
        '/snap/bin'  # Ubuntu snap packages
    ]
    
    if not node_path:
        print("🔍 Node.js not found in PATH, checking common locations...")
        for path_dir in additional_paths:
            if '*' in path_dir:
                # Handle glob patterns (like nvm)
                import glob
                for expanded_path in glob.glob(path_dir):
                    if os.path.exists(os.path.join(expanded_path, 'node')):
                        node_path = os.path.join(expanded_path, 'node')
                        break
            else:
                potential_node = os.path.join(path_dir, 'node')
                if os.path.exists(potential_node):
                    node_path = potential_node
                    break
    
    if not npm_path:
        # Try to find npm in the same directory as node
        if node_path:
            potential_npm = os.path.join(os.path.dirname(node_path), 'npm')
            if os.path.exists(potential_npm):
                npm_path = potential_npm
    
    # Test node
    if node_path:
        try:
            node_result = subprocess.run([node_path, '--version'], capture_output=True, text=True)
            if node_result.returncode == 0:
                print(f"✅ Found Node.js: {node_path}")
                print(f"   Version: {node_result.stdout.strip()}")
            else:
                print(f"❌ Node.js found but not working: {node_path}")
                return False, None, None
        except Exception as e:
            print(f"❌ Error testing Node.js: {e}")
            return False, None, None
    else:
        print("❌ Node.js not found anywhere")
        print("Please install Node.js from https://nodejs.org/ or use a package manager")
        return False, None, None
    
    # Test npm
    if npm_path:
        try:
            npm_result = subprocess.run([npm_path, '--version'], capture_output=True, text=True)
            if npm_result.returncode == 0:
                print(f"✅ Found npm: {npm_path}")
                print(f"   Version: {npm_result.stdout.strip()}")
                return True, node_path, npm_path
            else:
                print(f"❌ npm found but not working: {npm_path}")
                return False, None, None
        except Exception as e:
            print(f"❌ Error testing npm: {e}")
            return False, None, None
    else:
        print("❌ npm not found")
        print("npm should come with Node.js installation")
        return False, None, None

def main():
    print("🚀 PDF Processing Workspace Setup")
    print("=" * 40)
    
    # Check prerequisites
    found, node_path, npm_path = check_node_npm()
    if not found:
        print("\n❌ Setup aborted. Please ensure Node.js is properly installed.")
        print("\nDebugging tips:")
        print("1. Try running 'node --version' in your terminal")
        print("2. If using nvm, try 'nvm use node' first")
        print("3. If using volta, try 'volta install node@latest'")
        print("4. Check that Node.js is in your PATH")
        return False
    
    print()
    
    # Setup workspace
    success = setup_pdf_workspace(node_path=node_path, npm_path=npm_path)
    
    if success:
        print("\n🎉 Setup completed successfully!")
        print("\nNext steps:")
        print("1. Your Python scripts will now automatically use the workspace")
        print("2. Test with: cd pdf_stable_workspace && node extract_pdf.js path/to/test.pdf")
        print("3. Run your sentence mapping scripts as normal")
    else:
        print("\n❌ Setup failed. Please check the error messages above.")
    
    return success

if __name__ == "__main__":
    main()